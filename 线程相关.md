#### linux中线程是怎么创建的？
pthreads是一套标准，或者说规范，那么linux下是怎么实现这套规范的？通过glibc。那么从系统调用层次来说，线程是如何被创建的？答案是clone系统调用。NTPL基于clone和内核模型提供过了1:1的线程模型，线程和其他任何进程没有太大区别，除了他们共享特性支援。

#### 线程有父线程么？怎么查看？
进程的ppid可以通过 `cat /proc/<pid>/status` 中的PPid字段查看到，所以我们也用同样的方法去查发现，所有的线程的ppid和主线程的ppid相同，也就是进程的ppid相同。

#### linux clone 和 fork的区别是什么？
clone 有两种，一种是glibc的封装，一种是系统调用。clone 的man 说明是create一个child process，好像和 fork没啥区别。
但是man明确说明，clone允许子进程共享父进程的部分 execution context，注意这里的执行上下文不是代码段，而是比较宽泛的概念，比如内存空间，文件描述符表，以及信号处理函数表。所以clone很重要的一个应用就是实现线程。
  
glibc-clone的很重要的一个区别是 clone会指定入口函数，而不是fork一样子进程也往后执行同样的代码。其实系统调用的clone和fork是差不多的，也是从父进程clone调用点开始往下执行，

#### linux中线程之间的同步系统调用是什么？
futex，系统调用是了解实现机制的分界线，系统提供的功能可以都从这里入手。比如pthread中提供的pthread_mutex_lock,pthread_cond_t师傅不是都是基于fetux来实现的呢？

#### 线程的等待为什么叫join

join本意是加入，对应的detach叫分离。
glibc中的thread_join调用lll_wait_tid 实现
