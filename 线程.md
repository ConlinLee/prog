
#### 线程的alternate signal stack是什么？

#### linux中线程是怎么创建的？
pthreads是一套标准，或者说规范，那么linux下是怎么实现这套规范的？通过glibc。那么从系统调用层次来说，线程是如何被创建的？答案是clone系统调用。NTPL基于clone和内核模型提供过了1:1的线程模型，线程和其他任何进程没有太大区别，除了他们共享特性支援。

#### 线程数量的限制两种可能
一般有两种，the RLIMIT_NPROC soft resource limit (set via setrlimit(2)),  which  limits  the  number  of  process  for  a  real  user  ID,  was  reached;
or the kernel's system-wide limit on the number of threads, /proc/sys/kernel/threads-max, was reached.

#### 线程创建默认的站大小
On Linux/x86-32, the default stack size for a new thread is 2 megabytes.

#### pthread_create创建的线程的信号掩码
会继承调用线程的信号掩码，The new thread inherits a copy of the creating thread's signal mask。

#### pthread_create创建线程的pending信号集合
pending 信号集合为空。

#### pthread_create会继承调用线程的能力集
The new thread inherits copies of the calling thread's capability sets  (see  capabilities(7))

#### pthread_create会继承CPU亲和性
The new thread inherits copies of the calling thread's CPU  affinity  mask  (see sched_setaffinity(2)).

#### 线程的退出
pthread_create创建的线程退出有四种情况，可以参见man下pthread_create。

#### 只让某一个线程退出的方法
其实就是发信号，另外进程要先注册指定的信号处理函数，不然大部分的信号回让整个进程退出。
```
pthread_kill(h->thread_id, SIGABRT);
```

#### 线程有父线程么？怎么查看？
进程的ppid可以通过 ```cat /proc/<pid>/status``` 中的PPid字段查看到，所以我们也用同样的方法去查发现，所有的线程的ppid和主线程的ppid相同，也就是进程的ppid相同。

#### linux clone 和 fork的区别是什么？
clone 有两种，一种是glibc的封装，一种是系统调用。clone 的man 说明是create一个child process，好像和 fork没啥区别。
但是man明确说明，clone允许子进程共享父进程的部分 execution context，注意这里的执行上下文不是代码段，而是比较宽泛的概念，比如内存空间，文件描述符表，以及信号处理函数表。所以clone很重要的一个应用就是实现线程。
  
glibc-clone的很重要的一个区别是 clone会指定入口函数，而不是fork一样子进程也往后执行同样的代码。其实系统调用的clone和fork是差不多的，也是从父进程clone调用点开始往下执行，

#### linux中线程之间的同步系统调用是什么？
futex，系统调用是了解实现机制的分界线，系统提供的功能可以都从这里入手。比如pthread中提供的pthread_mutex_lock,pthread_cond_t师傅不是都是基于fetux来实现的呢？

#### mutex和semaphore区别

mutex, pthread_mutex_unlock有很重要的一点是，那个线程lock，就得由那个线程unlock，否者会有EPERM错误。
就算是递归的mutex，也一样，一个thread可以将lock count 涨上去，但是不能由其他的thread降下来。只有count为0才可以被其他的thread得到。所以，这是一个线程互斥访问资源的功能。

semaphore 的本意是一个发送信号的系统，通过两面旗来完成，一个人通过挥动手臂来代表不同的含义。来源于火车站的信号灯，本身含有【通知】的含义。知乎上有人说 semaphore 一个很重要的目的是为了调度线程，让产生资源的线程和消费资源的线程合乎逻辑得进行执行。

#### 线程的等待为什么叫join

join本意是加入，对应的detach叫分离。
glibc中的thread_join调用lll_wait_tid 实现

#### pthread_cond_wait 为什么需要传递 mutex 参数？

https://www.zhihu.com/question/24116967

关于pthread_cond_wait这个接口，unix环境高级编程上有一段说明:

pthread_cond_wait需要mutex来保护条件变量，因为mutex可以保证原子得执行下面两个操作:

1. 调用线程检查条件变量。
2. 把自己放到条件变量的等待线程队列并进入阻塞状态。

这样就可以避免调用线程在检查条件并进入阻塞状态期间，其他线程调用pthread_cond_signal，使得信号时没有被阻塞线程收到。

这段话的主要意思是，通过mutex来保证线程发信号时，另外一个线程已经完成检查并进入阻塞状态。
也就是说，一个线程在检查条件变量时先持有mutext，这样其他线程就没法signal，因为可以通过编码来实现在signal前先获取mutex。


查过这个接口的man文档，文档里提到，这个接口可以保证释放mutex并阻塞在条件变量上这个过程的原子性。这个解释好像比《unix环境高级编程》里说的更准确一些。不过好像说的是同一个意思。

**本质上就是要实现，线程释放锁进入等待状态，这个过程中不会发生别的线程并发送信号，因为如果发生，那么这个信号无法被前面的阻塞线程接收到。**

但这也许并不是pthread_cond_wait需要传入mutex的根本原因，这个接口自己就应该能保证：检查条件变量并进入阻塞状态等信号这个过程的原子性。

因为这两个操作本身和mutex有什么关系呢？而且pthread_cond_signal调用接口本身也不和mutex关联，是程序员自己来保证调用前先获取mutex。


从功能上来说，还有一个地方的原子性比较重要：（1）被告知条件变量满足，线程唤醒并再次持有mutex锁。这两个操作必须一同完成。也许释放mutex线程阻塞的原子性，和唤醒并再次持有锁的原子性都重要。

之所以需要mutex，关键还是在于业务本身需要互斥，只是这个需要时间来触发而已，如果只是一个信号，没法保证业务上的原子性。单单收发信号的原子性并不能解决业务的互斥问题。所以需要通过引入mutex来进行线程同步，mutex是功能的根本，毕竟解决线程之间的同步才是目的。
