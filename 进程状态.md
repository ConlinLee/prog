https://access.redhat.com/sites/default/files/attachments/processstates_20120831.pdf



```
A process is an instance of a computer program that is currently being executed.
Associated with a process is a variety of attributes  that extend or limit its ability to access resources on the computer
```

## UNDERSTANDING PROCESS TYPES

There are different types of processes in a Linux system. 
These types include user processes, daemon processes, and kernel processes
Changing kernel processes, however, may require recompiling the kernel.

## INTRODUCING SYSTEM STATES

p->state = TASK_RUNNING

## fork出的进程和父进程的区别

* 独立的pid
* ppid是父进程pid
* 不会集成父进程的内存锁（参考mlock和mlockall）
* 子进程的资源使用率和CPU计数重置为0
* 子进程的 pending-signal-set 置空
* 子进程不继承 semaphore adjustments
* 子进程不继承 record locks
* 子进程不继承 timer
* 子进程不继承突出的异步IO操作
* 子进程不继承异步IO上下文

Let's see how a process reaches a Running state. When you fire off a command such as ls, a shell (bash)
searches the directories in the search path stored in the PATH environment variable to find where the ls
command is located. Once the ls file is found, the shell clones itself using the forking method mentioned
earlier, and then the new child process replaces the binary image it was executing (the shell) with the ls
command's executable binary image.

## system calls

A CPU can execute either in kernel mode or in user mode. When a user initiates a process, the process
starts working in user mode. That user mode process does not have access to kernel data structures or
algorithms. Each CPU type provides special instructions to switch from user mode to kernel mode. If a userlevel process wants to access kernel data structures or algorithms, then it requests that information through
system calls that deal with the file subsystem or the process control subsystem. Examples of these system
calls include:
• File subsystem system calls: open(), close(), read(), write(), chmod(), and chown()
• Process control system calls: fork(), exec(), exit(), wait(), brk(), and signal()
