https://access.redhat.com/sites/default/files/attachments/processstates_20120831.pdf

A process is an instance of a computer program that is currently being executed.
Associated with a process is a variety of attributes  that extend or limit its ability to access resources on the computer

## UNDERSTANDING PROCESS TYPES

There are different types of processes in a Linux system. 
These types include user processes, daemon processes, and kernel processes
Changing kernel processes, however, may require recompiling the kernel.

## INTRODUCING SYSTEM STATES

p->state = TASK_RUNNING

## fork出的进程和父进程的区别

* 独立的pid
* ppid是父进程pid
* 不会集成父进程的内存锁（参考mlock和mlockall）
* 子进程的资源使用率和CPU计数重置为0
* 子进程的 pending-signal-set 置空
* 子进程不继承 semaphore adjustments
* 子进程不继承 record locks
* 子进程不继承 timer
* 子进程不继承突出的异步IO操作
* 子进程不继承异步IO上下文

Let's see how a process reaches a Running state. When you fire off a command such as ls, a shell (bash)
searches the directories in the search path stored in the PATH environment variable to find where the ls
command is located. Once the ls file is found, the shell clones itself using the forking method mentioned
earlier, and then the new child process replaces the binary image it was executing (the shell) with the ls
command's executable binary image.

## system calls

A CPU can execute either in kernel mode or in user mode. When a user initiates a process, the process
starts working in user mode. That user mode process does not have access to kernel data structures or
algorithms. Each CPU type provides special instructions to switch from user mode to kernel mode. If a userlevel process wants to access kernel data structures or algorithms, then it requests that information through
system calls that deal with the file subsystem or the process control subsystem. Examples of these system
calls include:

* File subsystem system calls: open(), close(), read(), write(), chmod(), and chown()
* Process control system calls: fork(), exec(), exit(), wait(), brk(), and signal()

## process states

#### Running
The process that is executing and using the CPU at a particular moment is called a running process.

#### Runnable State
When a process is in a Runnable state, it means it has all the resources it needs to run, except that the CPU
is not available. The Runnable state of this process is shown as R in ps output

Consider a example. A process is dealing with I/O, so it does not immediately need the CPU. When the
process finishes the I/O operation, a signal is generated to the CPU and the scheduler keeps that process in
the run queue (the list of ready-to-run processes maintained by the kernel). When the CPU is available, this
process will enter into Running state.

一个进程完成IO后回触发中断，中断处理程序会产生信号并告知CPU。调度器会将该进程的PID放进等待队列。

#### Sleeping

Consider a example. A process is dealing with I/O, so it does not immediately need the CPU. When the
process finishes the I/O operation, a signal is generated to the CPU and the scheduler keeps that process in
the run queue (the list of ready-to-run processes maintained by the kernel). When the CPU is available, this
process will enter into Running state.

#### Uninterruptible Sleep State

signals accumulated during the sleep are noticed when the process returns from the system call or trap. 

#### Terminate/Stop State

When a process
runs the exit system call, it releases its data structures, but it does not release its slot in the process table.
Instead, it sends a SIGCHLD signal to the parent. It is up to the parent process to release the child process
slot so that the parent can determine if the process exited successfully.

Between the time when the process terminates and the parent releases the child process, the child enters
into what is referred to as a Zombie state. A process can remain in a Zombie state if the parent process
should die before it has a chance to release the process slot of the child process. The reason you cannot kill
a Zombie process is that you cannot send a signal to the process to kill it as the process no longer exists.
