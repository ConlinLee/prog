关于pthread_cond_wait这个接口，unix环境高级编程上有一段说明:

pthread_cond_wait需要mutex来保护条件变量，因为mutex可以保证原子性得执行下面两个操作:1. 调用线程检查条件变量。
2. 把自己放到条件变量的等待线程队列并进入阻塞状态。
这样，就可以避免调用线程在检查条件并进入阻塞期间，其他线程调用pthread_cond_signal，使得信号时没有被阻塞线程收到。
这段话的主要意思是，通过mutex来保证线程发信号时，另外一个线程已经完成检查并进入阻塞状态。


查过这个接口的man文档，文档里提到，这个接口可以保证释放mutex和线程阻塞在条件变量上这两件事的原子性，这个解释好像比《unix环境高级编程》里说的更准确一些。
不过好像说的是同一个意思，就是只要线程释放锁，进入等待状态，这个期间不会发生【别的线程得到锁并发送信号】这件事，因为如果发生，
那么这个信号自然无法被前面的阻塞线程接受到。

但这也许并不是pthread _cond_wait需要传入mutex的根本原因，这个接口自己就应该能保证：
（1）检查条件变量（2）进入阻塞状态等信号，这两步的原子性。因为这两个操作本身和mutex并没有关系。
只是pthread_cond_signal调用前通过获取锁来让发送操作和之前的原子操作更加有序得进行。

从功能上来说，还有一个地方的原子性比较重要：（1）被告知条件变量满足，线程唤醒（2）再次持有mutex锁。这两个操作必须一同完成。
也许释放mutex线程阻塞的原子性，和唤醒并再次持有锁的原子性都重要

其实，这个接口如果只是等信号，那么都不需要传入mutex就可以做到，一个线程检查条件变量后阻塞的原子性，另外一个线程发送信号的原子性。
这两者都和mutex为啥关系。只是如果不配合mutex，这个接口没有实际用处，单单收发信号的原子性并不能解决线程同步的问题。
所以需要通过引入mutex来进行线程同步，mutex是功能的根本，毕竟解决线程之间的同步才是目的。
