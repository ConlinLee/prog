## 进程

#### wait 和 waitpid

* wait是一个系统调用，其实，这是glibc的一个包装。一个最基本的函数，功能简单，即如果有子进程终止（不管是正常终止还是异常），都会立即返回。
如果没有一个子进程终止，则阻塞。看参数就可以发现，wait只有一个参数。返回值是终止的进程id。
wait如何做到等待指定的进程？只能wait一次，然后看看是不是我们等待的进程，如果不是，那么再调用一次wait。
wait会保存之前wait过的进程的信息，然后当wait某个进程时，会先比较已经保存的进程的退出信息列表中有没有，没有就wait一下。
所以，针对这种wait某一个特定的进程的需求，早期的unix支持的并不好，所以才有waitpid。

* waitpid比较起来就复杂很多，有很多参数可以控制，比如如果没有子进程终止也不会阻塞，还比如可以指定要等待的是哪个进程。
该接口增强在三个地方（1）可以指定特定进程。（2）可以不阻塞。（3）waitpid可以支持作业控制。
作业控制主要是停止（注意不是终止）和恢复，这两种情况，waitpid能获取到状态，而wait不行。对作业控制来说，这还是很重要的。
所以我们看到，shell中的作业控制（按下ctrl+z）时，shell在用户态的最后一个调用就是waitpid。


* wait3和wait4是从UNIX的BSD分支下来的，它的个功能比wait，waitpid多一点，就是可以知道终止进程的资源使用情况。
比如用户态CPU时间总量，内核态CPU时间总量，缺页次数，接收到的信号次数等。但是这两个函数已经不在标准的SUS中。 
所以当我们man wait3或者 man wait4时会告诉我们，These functions are obsolete; 
wait3 就是等待任一子进程，wait4就是可以指定某一进程。3、4表示的是参数个数。


## 线程

#### 线程的等待为什么叫join

join本意是加入，对应的detach叫分离。
glibc中的thread_join调用lll_wait_tid 实现
