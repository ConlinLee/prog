## 进程

#### wait 和 waitpid

* wait是一个系统调用，其实，这是glibc的一个包装。一个最基本的函数，功能简单，即如果有子进程终止（不管是正常终止还是异常），都会立即返回。
如果没有一个子进程终止，则阻塞。看参数就可以发现，wait只有一个参数。返回值是终止的进程id。
wait如何做到等待指定的进程？只能wait一次，然后看看是不是我们等待的进程，如果不是，那么再调用一次wait。
wait会保存之前wait过的进程的信息，然后当wait某个进程时，会先比较已经保存的进程的退出信息列表中有没有，没有就wait一下。
所以，针对这种wait某一个特定的进程的需求，早期的unix支持的并不好，所以才有waitpid。

* waitpid比较起来就复杂很多，有很多参数可以控制，比如如果没有子进程终止也不会阻塞，还比如可以指定要等待的是哪个进程。
该接口增强在三个地方（1）可以指定特定进程。（2）可以不阻塞。（3）waitpid可以支持作业控制。
作业控制主要是停止（注意不是终止）和恢复，这两种情况，waitpid能获取到状态，而wait不行。对作业控制来说，这还是很重要的。
所以我们看到，shell中的作业控制（按下ctrl+z）时，shell在用户态的最后一个调用就是waitpid。


* wait3和wait4是从UNIX的BSD分支下来的，它的个功能比wait，waitpid多一点，就是可以知道终止进程的资源使用情况。
比如用户态CPU时间总量，内核态CPU时间总量，缺页次数，接收到的信号次数等。但是这两个函数已经不在标准的SUS中。 
所以当我们man wait3或者 man wait4时会告诉我们，These functions are obsolete; 
wait3 就是等待任一子进程，wait4就是可以指定某一进程。3、4表示的是参数个数。


## 线程

#### 线程的等待为什么叫join

join本意是加入，对应的detach叫分离。
glibc中的thread_join调用lll_wait_tid 实现

#### pthread_cond_wait 中的 mutex

关于pthread_cond_wait这个接口，unix环境高级编程上有一段说明:

pthread_cond_wait需要mutex来保护条件变量，因为mutex可以保证原子得执行下面两个操作:

1. 调用线程检查条件变量。
2. 把自己放到条件变量的等待线程队列并进入阻塞状态。

这样就可以避免调用线程在检查条件并进入阻塞状态期间，其他线程调用pthread_cond_signal，使得信号时没有被阻塞线程收到。

这段话的主要意思是，通过mutex来保证线程发信号时，另外一个线程已经完成检查并进入阻塞状态。
也就是说，一个线程在检查条件变量时先持有mutext，这样其他线程就没法signal，因为可以通过编码来实现在signal前先获取mutex。



查过这个接口的man文档，文档里提到，这个接口可以保证释放mutex并阻塞在条件变量上这个过程的原子性。这个解释好像比《unix环境高级编程》里说的更准确一些。不过好像说的是同一个意思。

**本质上就是要实现，线程释放锁进入等待状态，这个过程中不会发生别的线程并发送信号，因为如果发生，那么这个信号无法被前面的阻塞线程接收到。**

但这也许并不是pthread_cond_wait需要传入mutex的根本原因，这个接口自己就应该能保证：检查条件变量并进入阻塞状态等信号这个过程的原子性。

因为这两个操作本身和mutex有什么关系呢？而且pthread_cond_signal调用接口本身也不和mutex关联，是程序员自己来保证调用前先获取mutex。


从功能上来说，还有一个地方的原子性比较重要：（1）被告知条件变量满足，线程唤醒并再次持有mutex锁。这两个操作必须一同完成。也许释放mutex线程阻塞的原子性，和唤醒并再次持有锁的原子性都重要。

之所以需要mutex，关键还是在于业务本身需要互斥，只是这个需要时间来触发而已，如果只是一个信号，没法保证业务上的原子性。单单收发信号的原子性并不能解决业务的互斥问题。所以需要通过引入mutex来进行线程同步，mutex是功能的根本，毕竟解决线程之间的同步才是目的。


#### c++ 的线程库以及同步库提供的接口和pthread接口的对应关系是什么？
